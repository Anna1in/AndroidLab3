
# Лабораторна робота №3
# &nbsp;Виконала студентка 3 курсу, групи ІО-21, Любченко Анна.
&nbsp;&nbsp;&nbsp; На тему :" Дослідження способів збереження даних"

Мета роботи: дослідити способи збереження даних (база даних, файлова система, тощо) та отримати практичні навички щодо використання сховищ даних.

Загальний функціонал та код майже не змінився в порівнянні з 2 лабораторною роботою, бо лабораторна розроблена на її базі +  додався вибір ще 1 позиції товару та компанії для варіативності. 

![image](https://github.com/user-attachments/assets/0c001d1a-ab6b-4091-a666-d17dd2dc7c21)

&nbsp;&nbsp;&nbsp; Відкриваючи програму ми бачимо екран, на якому зображено RadioButton `s, для обирання продукту та бренду. Та кнопку "ОК" для підтвердження вибору.
Вся інформація щодо цього фрагменту наявна в файлі InputFragment.kt та його манфіест файлі fragment_input.xml , а основа міститься в MainActivity.kt та його маніфест файлі activity_main.xml .

![image](https://github.com/user-attachments/assets/22809dd3-0a95-431c-a0c9-a619366f1de9)

&nbsp;&nbsp;&nbsp; Коли обираємо тільки один варіант і натискаємо кнопку "ОК", програма видає сповіщення, шо треба обрати 2 об'єкти.
  У коді це знаходиться у методі :"buttonOk.setOnClickListener" , а саме -
  
            if (selectedCompanyId == -1 || selectedProductId == -1) {
                            Toast.makeText(activity, "Оберіть компанію та товар", Toast.LENGTH_SHORT).show()
                        }


![image](https://github.com/user-attachments/assets/fb9c91d3-9424-4e67-b2ad-9fea5ef8201b)

&nbsp;&nbsp;&nbsp;Після натискання на кнопку "ОК" отримуємо відповідь у вигляді виведення обраної компанії та товару. Вся інформація щодо цього фрагменту наявна в файлі ResultFragment.kt та його маніфест файлі fragment_reault.xml.

&nbsp;&nbsp;Також для 3 лабораторної роботи було додано виведення сповіщення "вибір збережено"

&nbsp;&nbsp;У коді це знаходиться у методі :"buttonOk.setOnClickListener" , а саме -

          Toast.makeText(activity, "Вибір збережено", Toast.LENGTH_SHORT).show()

Та додано нове поле для тексту та кнопку "Відкрити" для виведення усіх минулих та поточного виборів. 

![image](https://github.com/user-attachments/assets/9ba8d6a0-f00c-495c-ac65-fc5aaf8aae92)

При натисканні на кнопку "Відкрити" - отримаємо виведення інформації в порядку запису.
Якщо дані відсутні - в текстовому полі з'являється текст "Немає збережених даних". 
Це реалізовано в методі "buttonOpen.setOnClickListener" , а саме - 

                if (savedData.isEmpty()) {
                                textViewAllResults.text = "Немає збережених даних"
                            } 
                            
У вигляді повідомлення це можна вивести , якщо замінити  


              textViewAllResults.text = "Немає збережених даних"
              
на

              Toast.makeText(activity, "Відомості в файлі відсутні.", Toast.LENGTH_SHORT).show()

&nbsp;&nbsp;&nbsp;Після натискання на кнопку "Cancel", фрагмент з виводом  ResultFragment.kt приховується і знову з'являється  InputFragment.kt з очищеними RadioButton `s.

# Висновок: 
Програма за варіантом 9, в якій є групи "Продукт" та "Бренд", обираючи які і натискаючи на кнопку "ОК"- вони виводяться у окреме поле іншого фрагменту. Також передбачено вивід повідомлення, коли обрано тільки бренд, або тільки продукт. За вимогами лабораторної роботи було додано збереження до файлу та вивід даниз послідовно збереженню у другому фрагменті результату. Передбачено вивід повідомлення при збереженні даних та вивід тексту "Немає збережених даних", якщо інформація у файлі відсутня. Програма реалізована на Android Studio. На мові програмування Kotlin. За допомогою Button, RadioButton, RadioGroup, Textview, Fragment, RadioGroup та відповідних методів які викликаються при натисканні кнопок. 

# Контрольні питання:
 &nbsp;&nbsp;1. Опишіть як організована робота з налаштуваннями (даними у вигляді пари «ключ-значення»).

 
Для збереження невеликих налаштувань використовується SharedPreferences. Це механізм зберігання даних у форматі ключ-значення.
Основні методи SharedPreferences:
 &nbsp;&nbsp;putString(key, value) – записати строкове значення.
 &nbsp;&nbsp;getString(key, defaultValue) – отримати строкове значення.
 &nbsp;&nbsp;putInt(), putBoolean(), putFloat(), putLong() – інші типи значень.
 &nbsp;&nbsp;remove(key) – видалити значення.
 &nbsp;&nbsp;clear() – очистити всі дані.

 &nbsp;&nbsp;2. Опишіть типи сховищ файлів та причини їх використання.

Є 4 типа файлових сховищ.  
1. Внутрішнє сховище (Internal Storage) - Доступне лише для конкретного додатка. Дані видаляються при видаленні програми. Використовується для конфіденційних даних.
2. Зовнішнє сховище (External Storage) - Доступне для інших додатків і користувача. Використовується для великих файлів (фото, відео, документи).
3. Кеш-пам’ять (Cache Storage) - Використовується для тимчасових даних (завантажені зображення, API-відповіді). Android може автоматично видаляти ці файли.
4. Бази даних (SQLite, Room) - Використовуються для збереження структурованих даних.

 &nbsp;&nbsp;3. Опишіть процес роботи з файлами та файловою системою.
 
 &nbsp;&nbsp;Для внутрішнього сховища використовую openFileOutput() та openFileInput().
 &nbsp;&nbsp;Для зовнішнього сховища перевіряю дозвіл WRITE_EXTERNAL_STORAGE та використовую getExternalFilesDir().
 &nbsp;&nbsp;Для роботи з файлами також використовую FileInputStream та FileOutputStream.
 &nbsp;&nbsp;В Android можна працювати з файлами через Internal Storage та External Storage.
Приклад запису у внутрішнє сховище:

                    val fileName = "example.txt"
                    val fileContents = "Привіт, Android!"
                    context.openFileOutput(fileName, Context.MODE_PRIVATE).use {
                        it.write(fileContents.toByteArray())
                    }

Приклад читання з файлу:

                    val fileInput = context.openFileInput(fileName)
                    val text = fileInput.bufferedReader().use { it.readText() }


 &nbsp;&nbsp;4. Опишіть процес роботи з базами даних SQLite за допомогою класу SQLiteOpenHelper, наведіть переваги та недоліки.
 
 &nbsp;&nbsp;Використовую SQLiteOpenHelper для створення та оновлення бази даних.
Реалізую onCreate(SQLiteDatabase db) для створення таблиць та onUpgrade() для їх оновлення.
Виконую запити через db.insert(), db.query(), db.update().
 Створення класу, що керує БД за допомогою класу SQLiteOpenHelper:

 
                    class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, "MyDB", null, 1) {
                        override fun onCreate(db: SQLiteDatabase) {
                            db.execSQL("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
                        }
                    
                        override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
                            db.execSQL("DROP TABLE IF EXISTS users")
                            onCreate(db)
                        }
                    }

Переваги: Вбудована в Android та достатня для невеликих програм.
Недоліки: Потребує написання SQL-запитів вручну та відсутня автоматична перевірка даних.

 &nbsp;&nbsp;5. Як відбувається робота з БД за допомогою бібліотеки Room, наведіть переваги та недоліки.

 
 &nbsp;&nbsp;&nbsp;Використовую анотації @Entity, @Dao, @Database для створення структури БД.
Room генерує код для запитів автоматично.
 &nbsp;&nbsp;&nbsp;Переваги: Менше коду, безпечні SQL-запити, інтеграція з LiveData.
Недоліки: Складніша настройка, більший розмір APK.
 
 &nbsp;&nbsp;6. Наведіть характеристики екранів мобільних пристроїв.

 
Діагональ екрану – вимірюється в дюймах.
Роздільна здатність – кількість пікселів (наприклад, 1080x2400).
Щільність пікселів (dpi, ppi) – впливає на чіткість зображення.
Частота оновлення – 60Hz, 90Hz, 120Hz тощо.

 &nbsp;&nbsp;7. Наведіть класифікацію та відмінності технологій (типів) екранів мобільних пристроїв.

 
 &nbsp;&nbsp;&nbsp;&nbsp;LCD (IPS, TFT, PLS) – хороша кольоропередача, економія енергії.
 &nbsp;&nbsp;&nbsp;OLED, AMOLED – яскраві кольори, кращий контраст, вищий рівень чорного.
 &nbsp;&nbsp;&nbsp;E-Ink – використовується в електронних книгах, мінімальне енергоспоживання.

 &nbsp;&nbsp;8. Наведіть поняття та характеристику сенсорних екранів.

 &nbsp;&nbsp;&nbsp;Резистивні – реагують на тиск, працюють зі стилусом.
 &nbsp;&nbsp;&nbsp;Ємнісні – працюють при дотику пальцем, підтримують мультитач.

 &nbsp;&nbsp;9. Наведіть загальну класифікацію сенсорних екранів.

 
 &nbsp;&nbsp;&nbsp;&nbsp;Резистивні – дешевші, працюють в рукавичках, але менш чутливі.
 &nbsp;&nbsp;&nbsp;&nbsp;Ємнісні – більш чутливі, підтримують жести, потребують дотику шкіри.

 &nbsp;&nbsp;10. Наведіть рекомендації щодо розробки інтерфейсів для сенсорних екранів.
 
 &nbsp;&nbsp;&nbsp;&nbsp;Адаптивний дизайн для різних екранів.
Використовувати великі інтерактивні елементи (мінімум 48dp).
Мінімізувати текст, зосереджуючись на іконках та зрозумілих елементах UI.
Використовувати жести для навігації.
